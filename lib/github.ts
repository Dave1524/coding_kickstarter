/**
 * GitHub API client for boilerplate generation
 * Uses Octokit REST client for GitHub API operations
 */

import { Octokit } from '@octokit/rest';

// Template repository configuration
const TEMPLATE_REPO_OWNER = process.env.TEMPLATE_REPO_OWNER || 'Dave1524';
const TEMPLATE_REPO_NAME = process.env.TEMPLATE_REPO_NAME || 'coding-kickstarter-template';

export interface GitHubRepo {
  id: number;
  name: string;
  full_name: string;
  html_url: string;
  clone_url: string;
  ssh_url: string;
  default_branch: string;
  private: boolean;
}

export interface CreateRepoOptions {
  projectName: string;
  description?: string;
  isPrivate?: boolean;
}

export interface GitHubError {
  status: number;
  message: string;
  documentation_url?: string;
}

/**
 * Create a new Octokit instance with the provided token
 */
export function createOctokitClient(token: string): Octokit {
  return new Octokit({ auth: token });
}

/**
 * Validate a GitHub token by checking the authenticated user
 */
export async function validateToken(token: string): Promise<{
  valid: boolean;
  username?: string;
  error?: string;
}> {
  try {
    const octokit = createOctokitClient(token);
    const { data: user } = await octokit.users.getAuthenticated();
    return {
      valid: true,
      username: user.login,
    };
  } catch (error) {
    const ghError = error as { status?: number; message?: string };
    return {
      valid: false,
      error: ghError.message || 'Invalid token',
    };
  }
}

/**
 * Create a new repository from the template
 */
export async function createRepoFromTemplate(
  token: string,
  options: CreateRepoOptions
): Promise<GitHubRepo> {
  const octokit = createOctokitClient(token);

  // Sanitize project name for GitHub (lowercase, alphanumeric, hyphens)
  const sanitizedName = sanitizeRepoName(options.projectName);

  try {
    const { data: repo } = await octokit.repos.createUsingTemplate({
      template_owner: TEMPLATE_REPO_OWNER,
      template_repo: TEMPLATE_REPO_NAME,
      name: sanitizedName,
      description: options.description || `Generated by Coding Kickstarter`,
      private: options.isPrivate ?? false,
      include_all_branches: false,
    });

    return {
      id: repo.id,
      name: repo.name,
      full_name: repo.full_name,
      html_url: repo.html_url,
      clone_url: repo.clone_url,
      ssh_url: repo.ssh_url,
      default_branch: repo.default_branch || 'main',
      private: repo.private,
    };
  } catch (error) {
    const ghError = error as { status?: number; message?: string };
    
    // Handle specific GitHub errors
    if (ghError.status === 422) {
      throw new Error(`Repository name "${sanitizedName}" already exists or is invalid`);
    }
    if (ghError.status === 401) {
      throw new Error('GitHub token is invalid or expired');
    }
    if (ghError.status === 403) {
      throw new Error('GitHub rate limit exceeded or insufficient permissions');
    }
    if (ghError.status === 404) {
      throw new Error('Template repository not found');
    }
    
    throw new Error(ghError.message || 'Failed to create repository');
  }
}

/**
 * Update a file in the repository
 */
export async function updateRepoFile(
  token: string,
  repoFullName: string,
  filePath: string,
  content: string,
  commitMessage: string
): Promise<void> {
  const octokit = createOctokitClient(token);
  const [owner, repo] = repoFullName.split('/');

  try {
    // Get current file to get its SHA (required for update)
    let sha: string | undefined;
    try {
      const { data: existingFile } = await octokit.repos.getContent({
        owner,
        repo,
        path: filePath,
      });
      
      if (!Array.isArray(existingFile) && existingFile.type === 'file') {
        sha = existingFile.sha;
      }
    } catch {
      // File doesn't exist, that's fine for new files
    }

    // Create or update the file
    await octokit.repos.createOrUpdateFileContents({
      owner,
      repo,
      path: filePath,
      message: commitMessage,
      content: Buffer.from(content).toString('base64'),
      sha,
    });
  } catch (error) {
    const ghError = error as { message?: string };
    throw new Error(`Failed to update ${filePath}: ${ghError.message}`);
  }
}

/**
 * Update multiple files in a single commit
 */
export async function updateRepoFiles(
  token: string,
  repoFullName: string,
  files: Array<{ path: string; content: string }>,
  commitMessage: string
): Promise<void> {
  const octokit = createOctokitClient(token);
  const [owner, repo] = repoFullName.split('/');

  try {
    // Get the default branch reference
    const { data: ref } = await octokit.git.getRef({
      owner,
      repo,
      ref: 'heads/main',
    });

    // Get the current commit
    const { data: commit } = await octokit.git.getCommit({
      owner,
      repo,
      commit_sha: ref.object.sha,
    });

    // Create blobs for each file
    const blobs = await Promise.all(
      files.map(async (file) => {
        const { data: blob } = await octokit.git.createBlob({
          owner,
          repo,
          content: Buffer.from(file.content).toString('base64'),
          encoding: 'base64',
        });
        return {
          path: file.path,
          mode: '100644' as const,
          type: 'blob' as const,
          sha: blob.sha,
        };
      })
    );

    // Create a new tree
    const { data: tree } = await octokit.git.createTree({
      owner,
      repo,
      base_tree: commit.tree.sha,
      tree: blobs,
    });

    // Create a new commit
    const { data: newCommit } = await octokit.git.createCommit({
      owner,
      repo,
      message: commitMessage,
      tree: tree.sha,
      parents: [ref.object.sha],
    });

    // Update the reference
    await octokit.git.updateRef({
      owner,
      repo,
      ref: 'heads/main',
      sha: newCommit.sha,
    });
  } catch (error) {
    const ghError = error as { message?: string };
    throw new Error(`Failed to update files: ${ghError.message}`);
  }
}

/**
 * Get the ZIP download URL for a repository
 */
export function getRepoZipUrl(repoFullName: string, branch: string = 'main'): string {
  return `https://github.com/${repoFullName}/archive/refs/heads/${branch}.zip`;
}

/**
 * Get the template repository URL
 */
export function getTemplateRepoUrl(): string {
  return `https://github.com/${TEMPLATE_REPO_OWNER}/${TEMPLATE_REPO_NAME}`;
}

/**
 * Get the "Use this template" URL for GitHub
 */
export function getUseTemplateUrl(): string {
  return `https://github.com/${TEMPLATE_REPO_OWNER}/${TEMPLATE_REPO_NAME}/generate`;
}

/**
 * Sanitize a project name for use as a GitHub repository name
 */
export function sanitizeRepoName(name: string): string {
  return name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9-]/g, '-') // Replace non-alphanumeric with hyphens
    .replace(/-+/g, '-') // Replace multiple hyphens with single
    .replace(/^-|-$/g, '') // Remove leading/trailing hyphens
    .substring(0, 100); // GitHub repo names max 100 chars
}

/**
 * Generate PKCE code verifier and challenge
 * Following GitHub OAuth best practices: https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps
 * PKCE uses S256 method: SHA-256 hash of code verifier, base64url encoded
 */
export async function generatePKCE(): Promise<{ codeVerifier: string; codeChallenge: string }> {
  // Generate a random code verifier (43-128 characters)
  // Using 43 characters (86 hex characters = 43 bytes) as minimum recommended
  const array = new Uint8Array(43);
  crypto.getRandomValues(array);
  // Convert to base64url-safe string
  const codeVerifier = Buffer.from(array)
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '')
    .substring(0, 128); // Max 128 characters
  
  // Generate code challenge: SHA-256 hash of verifier, base64url encoded
  const encoder = new TextEncoder();
  const data = encoder.encode(codeVerifier);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const codeChallenge = Buffer.from(hashArray)
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, ''); // Remove padding for base64url
  
  return {
    codeVerifier,
    codeChallenge,
  };
}

/**
 * Build the GitHub OAuth authorization URL
 * Follows GitHub OAuth web application flow: https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow
 */
export function getGitHubOAuthUrl(
  clientId: string, 
  redirectUri: string, 
  state: string,
  codeChallenge?: string
): string {
  const params = new URLSearchParams({
    client_id: clientId,
    redirect_uri: redirectUri,
    scope: 'repo', // Minimal scope for repo creation
    state,
  });
  
  // Add PKCE parameters if provided (strongly recommended by GitHub)
  if (codeChallenge) {
    params.set('code_challenge', codeChallenge);
    params.set('code_challenge_method', 'S256'); // GitHub requires S256 (SHA-256)
  }
  
  return `https://github.com/login/oauth/authorize?${params.toString()}`;
}

/**
 * Exchange OAuth code for access token
 * Follows GitHub OAuth token exchange: https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#2-users-are-redirected-back-to-your-site-by-github
 */
export async function exchangeCodeForToken(
  code: string,
  clientId: string,
  clientSecret: string,
  codeVerifier?: string
): Promise<{ accessToken: string; tokenType: string; scope: string }> {
  const body: Record<string, string> = {
    client_id: clientId,
    client_secret: clientSecret,
    code,
  };

  // Add PKCE code verifier if provided
  if (codeVerifier) {
    body.code_verifier = codeVerifier;
  }

  const response = await fetch('https://github.com/login/oauth/access_token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json', // Request JSON response format
    },
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    throw new Error(`Token exchange failed: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();

  if (data.error) {
    throw new Error(data.error_description || data.error);
  }

  if (!data.access_token) {
    throw new Error('No access token received from GitHub');
  }

  return {
    accessToken: data.access_token,
    tokenType: data.token_type || 'bearer',
    scope: data.scope || '',
  };
}

